function [ song ] = mlf2song( filename, song, modd, minlgap, minlsyl, merges, fileout, Fs )
% read a MLF file generated by HTK
% update the song data structure provided
% minlgap is the minimum length under with the gaps are deleted (ms)
% minlsyl is the minimum length under with the syllables are not recorded (ms)
% merge (merges=1) neighboring syllables if they are next to each other
% for greywarbler: minimum gap length 200ms, minimum syllable length 1000ms
%
% modd indicates if song.sequence is correct or if song.sequencetxt is
% modd=1: fills up song.sequencetxt and fills up song.sequence with 1
% modd=2: fills up both song.sequence and song.sequencetxt
%
%%% to process a directory containing .mlf files
% files = dir(fullfile(filesdir,'*.mlf')) ;
% song = [];
% for nfiles=1:numel(files)
%    song = mlf2song( fullfile(filesdir,files(nfiles).name), song, 60, 60, 1) ;
% end
%%% update the song sequences so that each syllable has a unique number
% fsyl = 0 ;
% for sg=1:numel(song)
%     song(sg).sequence = find(song(sg).sequence)+fsyl ;
%     fsyl = song(sg).sequence(end) ;
% end
% save('-v7','.../songs.mat','song') ;
%%% encode and save the syllables
% [syllab] = GetHTKMFCCfromSong(song,'.../syllab.mat','.../config');

if nargin<7,fileout=0; end
if nargin<6,merges=0; end
if nargin<5,minlsyl=0; end
if nargin<4,minlgap=0; end
if nargin<3,modd=1; end

fid = fopen(filename,'r') ;

tline = fgetl(fid);
if numel( strfind(tline,'#!MLF!#') )==0
    fprintf(1,('not a mlf file\n'));
    return;
end

n = numel(song)+1 ;
tline = fgetl(fid);
% first get the filename
if strfind(tline(1),'"')==1
    sgfilename = strrep(tline,'"','') ;
    [pathstr, name] = fileparts(sgfilename) ;
    song(n).filename = [name '.wav'] ;
    song(n).SyllableS = [] ;
    song(n).SyllableE = [] ;
    song(n).sequencetxt = {} ;
    song(n).sequence = [] ;
end

% need to get the Fs from the wav file
if nargin<8
    if exist(fullfile(pathstr,song(n).filename),'file')==2
        if is_octave()
            [~, Fs] = wavread(fullfile(pathstr,song(n).filename),1); % only read the first sample
        else
            [~, Fs] = audioread(fullfile(pathstr,song(n).filename),[1,1]); % only read the first sample
        end
    else
       %warningMessage = sprintf('Warning: file does not exist:\n%s', fullfile(pathstr,song(n).filename));
       error('file does not exist: %s\n', fullfile(pathstr,song(n).filename));
    end
end
song(n).Fs = Fs ;
if exist('y','var')
    song(n).duration = length(y)/Fs ;
else
    song(n).duration = 0 ;
end

% convert minl in samples from ms
minlgap = minlgap*(Fs/1000) ;
minlsyl = minlsyl*(Fs/1000) ;

% fill the song structure
tline = fgetl(fid) ;
while ischar(tline)
    if strcmp(tline,'.')==1, break, end % if the line is "." it means the eof is reached
    %[A, count, errmsg] = sscanf(tline,'%f %f syl%f %f') ;
    A = sscanf(tline,'%f %f syl%f %*f') ; % get beginning and end and syl number
    [B, ~, errmsg] = sscanf(tline,'%*f %*f %s %*f') ; % get the name
    if numel(errmsg)==0 %&& A(3)>0
        % convert 100ns -> samples under FsHz sampling frequency
        song(n).SyllableS = [song(n).SyllableS (A(1)*Fs)/10000000] ; 
        song(n).SyllableE = [song(n).SyllableE (A(2)*Fs)/10000000] ;
        song(n).sequencetxt{end+1} = char(B)' ;
        if modd==1
            song(n).sequence = [song(n).sequence 1] ;
        elseif modd==2 % a syllable number has been recognised in the format syl%f
            song(n).sequence = [song(n).sequence A(3)] ;
        elseif modd==3 % need to create a unique number identifier for this syllable (sum of ascii characters)
            song(n).sequence = [song(n).sequence sum(B)] ;
        end
%         sylid = str2double(A(3)) ;
%         if numel(sylid)==0
%             song(n).sequence = [song(n).sequencetxt; 1] ;
%         else
%             song(n).sequence = [song(n).sequencetxt; sylid] ;
%         end
    end
    tline = fgetl(fid) ;
end

fclose(fid) ;

if modd==3
    % check if the unique identifier for the syllable names are not equal (some of ascii characters)
    if numel(unique(song.sequencetxt))~=numel(unique(song.sequence))
        fprintf(1,'bug in the conversion from ascii character to unique identifier number, need to rename the sound chunks');
    end
    fprintf(1,'%s\n',filename) ;
    unikseq = unique(song.sequence) ;
    for unikseqidx=1:numel(unikseq)
        fprintf(1,'%.0f - %s\n',song.sequence(find(song.sequence==unikseq(unikseqidx),1,'first')),...
            char(song.sequencetxt(find(song.sequence==unikseq(unikseqidx),1,'first'))));
    end
end

if numel(song(n).SyllableS)>0
    if song(n).SyllableS(1)==0
        song(n).SyllableS(1)=1 ; end % starts at the first sample rather than 0
end

% if required, merge syllables when they follow each other,
% watch out the syllable names in the sequence (the name of the first syllable is kept)
if merges==1
    m = 1;
    while numel(song(n).SyllableS)>m
        if song(n).SyllableE(m)==song(n).SyllableS(m+1) && song(n).sequence(m)==song(n).sequence(m+1) && strcmp(song(n).sequencetxt(m),song(n).sequencetxt(m+1))
            song(n).SyllableE(m)=song(n).SyllableE(m+1) ;
            % if numel(song(n).SyllableS)>m+1
                song(n).SyllableS = [song(n).SyllableS(1:m) song(n).SyllableS(m+2:end)] ;
                song(n).SyllableE = [song(n).SyllableE(1:m) song(n).SyllableE(m+2:end)] ;
                song(n).sequencetxt = [song(n).sequencetxt(1:m) song(n).sequencetxt(m+2:end)] ;
                song(n).sequence = [song(n).sequence(1:m) song(n).sequence(m+2:end)] ;
            % else
            %     song(n).SyllableS = [song(n).SyllableS(1:m)] ;
            %     song(n).SyllableE = [song(n).SyllableE(1:m)] ;
            %     song(n).sequence = [song(n).sequence(1:m)] ;
            % end
        else
            m=m+1 ;
        end
    end
end

% delete gaps if they are shorter than minlgap
if minlgap>0
    m = 2;
    while numel(song(n).SyllableS)>m
        if (song(n).SyllableS(m)-song(n).SyllableE(m-1))<minlgap && song(n).sequence(m)==song(n).sequence(m+1) && strcmp(song(n).sequencetxt(m),song(n).sequencetxt(m+1))
            song(n).SyllableS = [song(n).SyllableS(1:m-1) song(n).SyllableS(m+1:end)] ;
            song(n).SyllableE = [song(n).SyllableE(1:m-2) song(n).SyllableE(m:end)] ;
                song(n).sequencetxt = [song(n).sequencetxt(1:m-2) song(n).sequencetxt(m:end)] ;
            song(n).sequence = [song(n).sequence(1:m-1) song(n).sequence(m+1:end)] ;
        else
            m=m+1 ;
        end
    end
end

% delete syllables which are too short
if minlsyl>0
    m = 1;
    while numel(song(n).SyllableS)>=m
        if (song(n).SyllableE(m)-song(n).SyllableS(m))<minlsyl
            song(n).SyllableS = [song(n).SyllableS(1:m-1) song(n).SyllableS(m+1:end)] ;
            song(n).SyllableE = [song(n).SyllableE(1:m-1) song(n).SyllableE(m+1:end)] ;
            song(n).sequencetxt = [song(n).sequencetxt(1:m-1) song(n).sequencetxt(m+1:end)] ;
            song(n).sequence = [song(n).sequence(1:m-1) song(n).sequence(m+1:end)] ;
        else
            m=m+1 ;
        end
    end
end

if fileout>0
    song=song(n);
    tmp=regexprep(filename(end:-1:1),'flm.','vaw.','once');tmp=tmp(end:-1:1); % allows to replace just once, the last one
    save('-v7',[tmp '.mat'],'song') ; % replace for compatibility with soong() and DisplaySong()
end
